pub mod globals { # [allow (unused_imports)] pub use super :: * ; # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1EntriesEntriesParams < '__lt > { pub TEXTURE_T : & '__lt wgpu :: TextureView , pub TEXTURE_S : & '__lt wgpu :: Sampler } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1Entries < '__lt > { pub TEXTURE_T : wgpu :: BindGroupEntry < '__lt > , pub TEXTURE_S : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup1Entries < '__lt > { pub fn new (params : BindGroup1EntriesEntriesParams < '__lt >) -> Self { Self { TEXTURE_T : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: TextureView (params . TEXTURE_T) } , TEXTURE_S : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Sampler (params . TEXTURE_S) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup1 (wgpu :: BindGroup) ; impl BindGroup1 { pub const INDEX : u32 = 1u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("draw::BindGroup1::LayoutDescriptor") , entries : & [# [doc = "@binding(1): TEXTURE_T"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(1): TEXTURE_S"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup1Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("draw::BindGroup1") , layout : & bind_group_layout , entries : & [bindings . TEXTURE_T , bindings . TEXTURE_S] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2EntriesEntriesParams < '__lt > { pub TEXT_MASK_T : & '__lt wgpu :: TextureView , pub TEXT_MASK_S : & '__lt wgpu :: Sampler , pub TEXT_COLOR_T : & '__lt wgpu :: TextureView , pub TEXT_COLOR_S : & '__lt wgpu :: Sampler } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2Entries < '__lt > { pub TEXT_MASK_T : wgpu :: BindGroupEntry < '__lt > , pub TEXT_MASK_S : wgpu :: BindGroupEntry < '__lt > , pub TEXT_COLOR_T : wgpu :: BindGroupEntry < '__lt > , pub TEXT_COLOR_S : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup2Entries < '__lt > { pub fn new (params : BindGroup2EntriesEntriesParams < '__lt >) -> Self { Self { TEXT_MASK_T : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: TextureView (params . TEXT_MASK_T) } , TEXT_MASK_S : wgpu :: BindGroupEntry { binding : 1u32 , resource : wgpu :: BindingResource :: Sampler (params . TEXT_MASK_S) } , TEXT_COLOR_T : wgpu :: BindGroupEntry { binding : 2u32 , resource : wgpu :: BindingResource :: TextureView (params . TEXT_COLOR_T) } , TEXT_COLOR_S : wgpu :: BindGroupEntry { binding : 3u32 , resource : wgpu :: BindingResource :: Sampler (params . TEXT_COLOR_S) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup2 (wgpu :: BindGroup) ; impl BindGroup2 { pub const INDEX : u32 = 2u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("draw::BindGroup2::LayoutDescriptor") , entries : & [# [doc = "@binding(2): TEXT_MASK_T"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(2): TEXT_MASK_S"] wgpu :: BindGroupLayoutEntry { binding : 1u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , } , # [doc = "@binding(2): TEXT_COLOR_T"] wgpu :: BindGroupLayoutEntry { binding : 2u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Texture { sample_type : wgpu :: TextureSampleType :: Float { filterable : true } , view_dimension : wgpu :: TextureViewDimension :: D2 , multisampled : false , } , count : None , } , # [doc = "@binding(2): TEXT_COLOR_S"] wgpu :: BindGroupLayoutEntry { binding : 3u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Sampler (wgpu :: SamplerBindingType :: Filtering) , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup2Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("draw::BindGroup2") , layout : & bind_group_layout , entries : & [bindings . TEXT_MASK_T , bindings . TEXT_MASK_S , bindings . TEXT_COLOR_T , bindings . TEXT_COLOR_S] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } } pub mod constants { # [allow (unused_imports)] pub use super :: * ; } pub mod structs { # [allow (unused_imports)] pub use super :: * ; impl super :: super :: common :: structs :: VertexInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos) as wgpu :: BufferAddress , shader_location : 0u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color) as wgpu :: BufferAddress , shader_location : 1u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv) as wgpu :: BufferAddress , shader_location : 2u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , text_uv) as wgpu :: BufferAddress , shader_location : 3u32 , format : wgpu :: VertexFormat :: Float32x2 , }] , } } } } pub mod entries { pub const FRAG_ENTRY_FS_MAIN : & str = "fs_main" ; pub fn fragment_entry_fs_main < '__lt > (targets : & '__lt [:: core :: option :: Option < wgpu :: ColorTargetState >]) -> super :: super :: FragmentEntry < '__lt > { super :: super :: FragmentEntry { entry_point : FRAG_ENTRY_FS_MAIN , targets , } } pub const VERT_ENTRY_VS_MAIN : & str = "vs_main" ; # [allow (non_snake_case)] pub fn vertex_entry_vs_main (VertexInput_step_mode : wgpu :: VertexStepMode) -> super :: super :: VertexEntry < 1usize > { super :: super :: VertexEntry { entry_point : VERT_ENTRY_VS_MAIN , buffers : [super :: super :: common :: structs :: VertexInput :: vertex_desc (VertexInput_step_mode)] , } } } pub const SOURCE : & str = "struct VertexInputX_naga_oil_mod_XMNXW23LPNYX {\n    @location(0) pos: vec2<f32>,\n    @location(1) color: vec4<f32>,\n    @location(2) uv: vec2<f32>,\n    @location(3) text_uv: vec2<f32>,\n}\n\nstruct VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) text_uv: vec2<f32>,\n}\n\nstruct CanvasGlobalsX_naga_oil_mod_XMNXW23LPNYX {\n    screen_size: vec2<f32>,\n}\n\n@group(0) @binding(0) \nvar<uniform> GLOBALSX_naga_oil_mod_XMNXW23LPNYX: CanvasGlobalsX_naga_oil_mod_XMNXW23LPNYX;\n@group(1) @binding(0) \nvar TEXTURE_T: texture_2d<f32>;\n@group(1) @binding(1) \nvar TEXTURE_S: sampler;\n@group(2) @binding(0) \nvar TEXT_MASK_T: texture_2d<f32>;\n@group(2) @binding(1) \nvar TEXT_MASK_S: sampler;\n@group(2) @binding(2) \nvar TEXT_COLOR_T: texture_2d<f32>;\n@group(2) @binding(3) \nvar TEXT_COLOR_S: sampler;\n\nfn vs_main_commonX_naga_oil_mod_XMNXW23LPNYX(vertex_idx_1: u32, vertex_1: VertexInputX_naga_oil_mod_XMNXW23LPNYX, uv: vec2<f32>) -> VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    var out_1: VertexOutputX_naga_oil_mod_XMNXW23LPNYX;\n\n    let _e6 = GLOBALSX_naga_oil_mod_XMNXW23LPNYX.screen_size;\n    out_1.pos = vec4<f32>(((((vertex_1.pos / _e6) * 2f) * vec2<f32>(1f, -1f)) + vec2<f32>(-1f, 1f)), 0f, 1f);\n    out_1.color = vertex_1.color;\n    out_1.uv = uv;\n    out_1.text_uv = vertex_1.text_uv;\n    let _e27 = out_1;\n    return _e27;\n}\n\n@vertex \nfn vs_main(@builtin(vertex_index) vertex_idx: u32, vertex: VertexInputX_naga_oil_mod_XMNXW23LPNYX) -> VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    let _e3 = textureDimensions(TEXTURE_T);\n    let _e7 = vs_main_commonX_naga_oil_mod_XMNXW23LPNYX(vertex_idx, vertex, (vertex.uv / vec2<f32>(_e3)));\n    return _e7;\n}\n\n@fragment \nfn fs_main(in: VertexOutputX_naga_oil_mod_XMNXW23LPNYX) -> @location(0) vec4<f32> {\n    var out: vec4<f32>;\n\n    out = in.color;\n    if (in.uv.x >= 0f) {\n        let _e10 = textureSample(TEXTURE_T, TEXTURE_S, in.uv);\n        let _e11 = out;\n        out = (_e11 * _e10);\n    }\n    if (in.text_uv.x >= 0f) {\n        if (in.text_uv.y >= 0f) {\n            let _e26 = textureDimensions(TEXT_MASK_T);\n            let _e29 = textureSample(TEXT_MASK_T, TEXT_MASK_S, (in.text_uv / vec2<f32>(_e26)));\n            let _e32 = out.w;\n            out.w = (_e32 * sqrt(_e29.x));\n        } else {\n            let _e36 = textureDimensions(TEXT_COLOR_T);\n            let _e45 = textureSample(TEXT_COLOR_T, TEXT_COLOR_S, ((in.text_uv / vec2<f32>(_e36)) + vec2<f32>(0f, 2f)));\n            let _e46 = out;\n            out = (_e46 * _e45);\n        }\n    }\n    let _e48 = out;\n    return _e48;\n}\n" ; pub fn create_pipeline_layout (device : & wgpu :: Device) -> wgpu :: PipelineLayout { device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("draw::PipelineLayout") , bind_group_layouts : & [& super :: common :: globals :: BindGroup0 :: get_bind_group_layout (device) , & super :: draw :: globals :: BindGroup1 :: get_bind_group_layout (device) , & super :: draw :: globals :: BindGroup2 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , } ,) } pub fn create_shader_module (device : & wgpu :: Device) -> wgpu :: ShaderModule { device . create_shader_module (wgpu :: ShaderModuleDescriptor { label : Some ("draw::ShaderModule") , source : wgpu :: ShaderSource :: Wgsl (self :: SOURCE . into ()) , }) }