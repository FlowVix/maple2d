pub mod globals { # [allow (unused_imports)] pub use super :: * ; # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0EntriesEntriesParams < '__lt > { pub GLOBALS : wgpu :: BufferBinding < '__lt > } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0Entries < '__lt > { pub GLOBALS : wgpu :: BindGroupEntry < '__lt > } impl < '__lt > BindGroup0Entries < '__lt > { pub fn new (params : BindGroup0EntriesEntriesParams < '__lt >) -> Self { Self { GLOBALS : wgpu :: BindGroupEntry { binding : 0u32 , resource : wgpu :: BindingResource :: Buffer (params . GLOBALS) } } } } # [cfg_attr (debug_assertions , derive (Debug))] # [allow (non_snake_case)] pub struct BindGroup0 (wgpu :: BindGroup) ; impl BindGroup0 { pub const INDEX : u32 = 0u32 ; # [allow (unused_doc_comments)] pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("common::BindGroup0::LayoutDescriptor") , entries : & [# [doc = "@binding(0): GLOBALS"] wgpu :: BindGroupLayoutEntry { binding : 0u32 , visibility : wgpu :: ShaderStages :: VERTEX_FRAGMENT , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < super :: structs :: CanvasGlobals > () as _) , } , count : None , }] , } ; pub fn get_bind_group_layout (device : & wgpu :: Device) -> wgpu :: BindGroupLayout { device . create_bind_group_layout (& Self :: LAYOUT_DESCRIPTOR) } pub fn from_bindings (device : & wgpu :: Device , bindings : BindGroup0Entries ,) -> Self { let bind_group_layout = Self :: get_bind_group_layout (& device) ; let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("common::BindGroup0") , layout : & bind_group_layout , entries : & [bindings . GLOBALS] , } ,) ; Self (bind_group) } pub fn get_bind_group (& self) -> & wgpu :: BindGroup { & self . 0 } } } pub mod constants { # [allow (unused_imports)] pub use super :: * ; pub const PI : f32 = 3.1415927f32 ; } pub mod structs { # [allow (unused_imports)] pub use super :: * ; # [allow (non_snake_case)] # [repr (C , align (8))] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct CanvasGlobals { # [doc = "size: 8, offset: 0x0, type: `vec2<f32>`"] pub screen_size : [f32 ; 2usize] } impl CanvasGlobals { pub fn new (screen_size : [f32 ; 2usize]) -> Self { Self { screen_size } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexInput { pub pos : [f32 ; 2usize] , pub color : [f32 ; 4usize] , pub uv : [f32 ; 2usize] , pub text_uv : [f32 ; 2usize] } impl VertexInput { pub fn new (pos : [f32 ; 2usize] , color : [f32 ; 4usize] , uv : [f32 ; 2usize] , text_uv : [f32 ; 2usize]) -> Self { Self { pos , color , uv , text_uv } } } # [allow (non_snake_case)] # [repr (C)] # [cfg_attr (debug_assertions , derive (Debug))] # [derive (PartialEq , Clone , Copy , Default , bytemuck :: Pod , bytemuck :: Zeroable)] pub struct VertexOutput { pos : [u8 ; const { 16usize }] , pub color : [f32 ; 4usize] , pub uv : [f32 ; 2usize] , pub text_uv : [f32 ; 2usize] } impl VertexOutput { pub fn new (color : [f32 ; 4usize] , uv : [f32 ; 2usize] , text_uv : [f32 ; 2usize]) -> Self { Self { pos : [0 ; const { 16usize }] , color , uv , text_uv } } } } pub mod entries { } pub const SOURCE : & str = "struct CanvasGlobals {\n    screen_size: vec2<f32>,\n}\n\nstruct VertexInput {\n    @location(0) pos: vec2<f32>,\n    @location(1) color: vec4<f32>,\n    @location(2) uv: vec2<f32>,\n    @location(3) text_uv: vec2<f32>,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) text_uv: vec2<f32>,\n}\n\nconst PI: f32 = 3.1415927f;\n\n@group(0) @binding(0) \nvar<uniform> GLOBALS: CanvasGlobals;\n\nfn vs_main_common(vertex_idx: u32, vertex: VertexInput, uv: vec2<f32>) -> VertexOutput {\n    var out: VertexOutput;\n\n    let _e6 = GLOBALS.screen_size;\n    out.pos = vec4<f32>(((vertex.pos / _e6) * 2f), 0f, 1f);\n    out.color = vertex.color;\n    out.uv = uv;\n    out.text_uv = vertex.text_uv;\n    let _e19 = out;\n    return _e19;\n}\n\n" ; pub fn create_pipeline_layout (device : & wgpu :: Device) -> wgpu :: PipelineLayout { device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("common::PipelineLayout") , bind_group_layouts : & [& super :: common :: globals :: BindGroup0 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , } ,) } pub fn create_shader_module (device : & wgpu :: Device) -> wgpu :: ShaderModule { device . create_shader_module (wgpu :: ShaderModuleDescriptor { label : Some ("common::ShaderModule") , source : wgpu :: ShaderSource :: Wgsl (self :: SOURCE . into ()) , }) }