pub mod globals { # [allow (unused_imports)] pub use super :: * ; } pub mod constants { # [allow (unused_imports)] pub use super :: * ; } pub mod structs { # [allow (unused_imports)] pub use super :: * ; impl super :: super :: common :: structs :: VertexInput { pub fn vertex_desc (step_mode : wgpu :: VertexStepMode) -> wgpu :: VertexBufferLayout < 'static > { wgpu :: VertexBufferLayout { array_stride : std :: mem :: size_of :: < Self > () as wgpu :: BufferAddress , step_mode , attributes : & [wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , pos) as wgpu :: BufferAddress , shader_location : 0u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , color) as wgpu :: BufferAddress , shader_location : 1u32 , format : wgpu :: VertexFormat :: Float32x4 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , uv) as wgpu :: BufferAddress , shader_location : 2u32 , format : wgpu :: VertexFormat :: Float32x2 , } , wgpu :: VertexAttribute { offset : :: core :: mem :: offset_of ! (Self , text_uv) as wgpu :: BufferAddress , shader_location : 3u32 , format : wgpu :: VertexFormat :: Float32x2 , }] , } } } } pub mod entries { pub const FRAG_ENTRY_FS_MAIN : & str = "fs_main" ; pub fn fragment_entry_fs_main < '__lt > (targets : & '__lt [:: core :: option :: Option < wgpu :: ColorTargetState >]) -> super :: super :: FragmentEntry < '__lt > { super :: super :: FragmentEntry { entry_point : FRAG_ENTRY_FS_MAIN , targets , } } pub const VERT_ENTRY_VS_MAIN : & str = "vs_main" ; # [allow (non_snake_case)] pub fn vertex_entry_vs_main (VertexInput_step_mode : wgpu :: VertexStepMode) -> super :: super :: VertexEntry < 1usize > { super :: super :: VertexEntry { entry_point : VERT_ENTRY_VS_MAIN , buffers : [super :: super :: common :: structs :: VertexInput :: vertex_desc (VertexInput_step_mode)] , } } } pub const SOURCE : & str = "struct VertexInputX_naga_oil_mod_XMNXW23LPNYX {\n    @location(0) pos: vec2<f32>,\n    @location(1) color: vec4<f32>,\n    @location(2) uv: vec2<f32>,\n    @location(3) text_uv: vec2<f32>,\n}\n\nstruct VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    @builtin(position) pos: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) text_uv: vec2<f32>,\n}\n\nstruct CanvasGlobalsX_naga_oil_mod_XMNXW23LPNYX {\n    screen_size: vec2<f32>,\n}\n\n@group(0) @binding(0) \nvar<uniform> GLOBALSX_naga_oil_mod_XMNXW23LPNYX: CanvasGlobalsX_naga_oil_mod_XMNXW23LPNYX;\n\nfn vs_main_commonX_naga_oil_mod_XMNXW23LPNYX(vertex_idx_1: u32, vertex_1: VertexInputX_naga_oil_mod_XMNXW23LPNYX, uv: vec2<f32>) -> VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    var out: VertexOutputX_naga_oil_mod_XMNXW23LPNYX;\n\n    let _e6 = GLOBALSX_naga_oil_mod_XMNXW23LPNYX.screen_size;\n    out.pos = vec4<f32>(((((vertex_1.pos / _e6) * 2f) * vec2<f32>(1f, -1f)) + vec2<f32>(-1f, 1f)), 0f, 1f);\n    out.color = vertex_1.color;\n    out.uv = uv;\n    out.text_uv = vertex_1.text_uv;\n    let _e27 = out;\n    return _e27;\n}\n\n@vertex \nfn vs_main(@builtin(vertex_index) vertex_idx: u32, vertex: VertexInputX_naga_oil_mod_XMNXW23LPNYX) -> VertexOutputX_naga_oil_mod_XMNXW23LPNYX {\n    let _e3 = vs_main_commonX_naga_oil_mod_XMNXW23LPNYX(vertex_idx, vertex, vertex.uv);\n    return _e3;\n}\n\n@fragment \nfn fs_main(in: VertexOutputX_naga_oil_mod_XMNXW23LPNYX) -> @location(0) vec4<f32> {\n    return vec4(1f);\n}\n" ; pub fn create_pipeline_layout (device : & wgpu :: Device) -> wgpu :: PipelineLayout { device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("stencil::PipelineLayout") , bind_group_layouts : & [& super :: common :: globals :: BindGroup0 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , } ,) } pub fn create_shader_module (device : & wgpu :: Device) -> wgpu :: ShaderModule { device . create_shader_module (wgpu :: ShaderModuleDescriptor { label : Some ("stencil::ShaderModule") , source : wgpu :: ShaderSource :: Wgsl (self :: SOURCE . into ()) , }) }